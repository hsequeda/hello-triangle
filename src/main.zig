const std = @import("std");
// const builtin = @import("builtin");
// const panic = std.debug.panic;

// usingnamespace @import("c.zig");

// // settings
// const SCR_WIDTH: u32 = 1920;
// const SCR_HEIGHT: u32 = 1080;

pub fn main() void {
    std.debug.print("Hello, world!\n", .{});

    // const ok = glfwInit();
    // if (ok == 0) {
    //     panic("Failed to initialise GLFW\n", .{});
    // }
    // defer glfwTerminate();

    // glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    // glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    // glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    // glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);

    // // glfw: initialize and configure
    // var window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "Learn OpenGL", null, null);
    // if (window == null) {
    //     panic("Failed to create GLFW window\n", .{});
    // }

    // glfwMakeContextCurrent(window);
    // const resizeCallback = glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    // // glad: load all OpenGL function pointers
    // if (gladLoadGLLoader(@ptrCast(GLADloadproc, glfwGetProcAddress)) == 0) {
    //     panic("Failed to initialise GLAD\n", .{});
    // }

    // // render loop
    // while (glfwWindowShouldClose(window) == 0) {
    //     // input
    //     processInput(window);

    //     // render
    //     glClearColor(0.2, 0.3, 0.3, 1.0);
    //     glClear(GL_COLOR_BUFFER_BIT);

    //     // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
    //     glfwSwapBuffers(window);
    //     glfwPollEvents();
    // }
}

// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly
// pub fn processInput(window: ?*GLFWwindow) callconv(.C) void {
//     if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
//         glfwSetWindowShouldClose(window, 1);
// }

// glfw: whenever the window size changed (by OS or user resize) this callback function executes
// pub fn framebuffer_size_callback(window: ?*GLFWwindow, width: c_int, height: c_int) callconv(.C) void {
//     // make sure the viewport matches the new window dimensions; note that width and
//     // height will be significantly larger than specified on retina displays.
//     glViewport(0, 0, width, height);
// }
